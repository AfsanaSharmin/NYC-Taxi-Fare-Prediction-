# -*- coding: utf-8 -*-
"""GEO_Monday.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g3unvpDMWNUSIMvPgIm5ptdKDe-6fHg3
"""

import pandas as pd
import numpy as np
from sklearn.cluster import DBSCAN
import matplotlib.pyplot as plt
from shapely.geometry import Polygon
from shapely.wkt import loads

# Function to extract the centroid (latitude, longitude) from WKT geometry
def extract_centroid(wkt_geom):
    polygon = loads(wkt_geom)
    return polygon.centroid.x, polygon.centroid.y

from google.colab import drive
drive.mount('/content/drive')
# Function to extract the centroid (latitude, longitude) from WKT geometry
def extract_centroid(wkt_geom):
    polygon = loads(wkt_geom)
    return polygon.centroid.x, polygon.centroid.y
# Load the taxi fare dataset
fare_file_path = "/content/drive/MyDrive/Dataset/Taxi_Fare_Dataset.xlsx"
df_fare = pd.read_excel(fare_file_path)

# Load the taxi zone geo data
geo_file_path = "/content/drive/MyDrive/Dataset/taxi_zone_geo.csv"
df_geo = pd.read_csv(geo_file_path)
# Load the datasets (you'll need to load these in your environment)
df_fare = pd.read_excel(fare_file_path)
df_geo = pd.read_csv(geo_file_path)

# Apply the function to extract the centroid for each zone
df_geo['centroid_lon'], df_geo['centroid_lat'] = zip(*df_geo['zone_geom'].apply(extract_centroid))

# Merge the centroid info with the fare dataset
df_fare = df_fare.merge(df_geo[['zone_id', 'centroid_lat', 'centroid_lon']], left_on='pickup_location_id', right_on='zone_id', how='left')
df_fare = df_fare.merge(df_geo[['zone_id', 'centroid_lat', 'centroid_lon']], left_on='dropoff_location_id', right_on='zone_id', how='left', suffixes=('_pickup', '_dropoff'))

# Filter data for Monday (day_of_week == 1)
df_monday = df_fare[df_fare['day_of_week'] == 1]

# Drop rows with NaN values in the centroid columns
df_monday = df_monday.dropna(subset=['centroid_lat_pickup', 'centroid_lon_pickup', 'centroid_lat_dropoff', 'centroid_lon_dropoff'])

# Haversine formula to calculate the distance between two lat/lon pairs
def haversine(lat1, lon1, lat2, lon2):
    R = 6371  # Radius of Earth in kilometers
    phi1, phi2 = np.radians(lat1), np.radians(lat2)
    delta_phi = np.radians(lat2 - lat1)
    delta_lambda = np.radians(lon2 - lon1)

    a = np.sin(delta_phi/2)**2 + np.cos(phi1) * np.cos(phi2) * np.sin(delta_lambda/2)**2
    c = 2 * np.arctan2(np.sqrt(a), np.sqrt(1-a))
    return R * c  # in kilometers

# Calculate the distance between pickup and dropoff using Haversine formula
df_monday['distance'] = haversine(df_monday['centroid_lat_pickup'], df_monday['centroid_lon_pickup'],
                                  df_monday['centroid_lat_dropoff'], df_monday['centroid_lon_dropoff'])

# Prepare data for clustering (pickup locations)
pickup_coords = df_monday[['centroid_lon_pickup', 'centroid_lat_pickup']]

# Apply DBSCAN clustering to pickup locations
dbscan_pickup = DBSCAN(eps=0.05, min_samples=10, metric='haversine')
df_monday['pickup_cluster'] = dbscan_pickup.fit_predict(np.radians(pickup_coords))

# Apply DBSCAN clustering to dropoff locations
dropoff_coords = df_monday[['centroid_lon_dropoff', 'centroid_lat_dropoff']]
dbscan_dropoff = DBSCAN(eps=0.05, min_samples=10, metric='haversine')
df_monday['dropoff_cluster'] = dbscan_dropoff.fit_predict(np.radians(dropoff_coords))

# Calculate the number of points in each cluster (for pickup and dropoff)
pickup_cluster_counts = df_monday['pickup_cluster'].value_counts()
dropoff_cluster_counts = df_monday['dropoff_cluster'].value_counts()

# Find the most dense cluster for pickup and dropoff (highest count)
most_dense_pickup_cluster = pickup_cluster_counts.idxmax()
most_dense_dropoff_cluster = dropoff_cluster_counts.idxmax()

# Function to find the nearest zone based on geographic proximity using Euclidean distance
def find_nearest_zone(cluster_coords, df_geo):
    # Get zone centroids (longitude, latitude)
    zone_coords = df_geo[['centroid_lon', 'centroid_lat']].values
    # Calculate Euclidean distance from cluster_coords to each zone centroid
    distances = np.sqrt(((zone_coords - cluster_coords) ** 2).sum(axis=1))  # Euclidean distance
    nearest_zone_idx = np.argmin(distances)
    return df_geo.iloc[nearest_zone_idx]['zone_name']

# Get the most dense pickup and dropoff areas by finding the nearest zones
pickup_area = find_nearest_zone([df_monday[df_monday['pickup_cluster'] == most_dense_pickup_cluster].iloc[0]['centroid_lon_pickup'],
                                 df_monday[df_monday['pickup_cluster'] == most_dense_pickup_cluster].iloc[0]['centroid_lat_pickup']], df_geo)

dropoff_area = find_nearest_zone([df_monday[df_monday['dropoff_cluster'] == most_dense_dropoff_cluster].iloc[0]['centroid_lon_dropoff'],
                                  df_monday[df_monday['dropoff_cluster'] == most_dense_dropoff_cluster].iloc[0]['centroid_lat_dropoff']], df_geo)

# Print out the most dense pickup and dropoff area
print(f"The most dense pickup cluster is in the area: {pickup_area}")
print(f"The most dense dropoff cluster is in the area: {dropoff_area}")

# Plot clusters for pickup and dropoff locations with increased point size
plt.figure(figsize=(12, 8))

# Plot pickup locations with color based on fare amount, larger points
plt.subplot(1, 2, 1)
scatter_pickup = plt.scatter(df_monday['centroid_lon_pickup'], df_monday['centroid_lat_pickup'],
                             c=df_monday['fare_amount'], cmap='viridis', s=50, alpha=0.7)  # Larger points
plt.title('Pickup Locations on Monday (Colored by Fare Amount)')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.colorbar(scatter_pickup, label='Fare Amount')

# Plot dropoff locations with color based on fare amount, larger points
plt.subplot(1, 2, 2)
scatter_dropoff = plt.scatter(df_monday['centroid_lon_dropoff'], df_monday['centroid_lat_dropoff'],
                              c=df_monday['fare_amount'], cmap='viridis', s=50, alpha=0.7)  # Larger points
plt.title('Dropoff Locations on Monday (Colored by Fare Amount)')
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.colorbar(scatter_dropoff, label='Fare Amount')

plt.tight_layout()
plt.show()